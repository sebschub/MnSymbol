
for scale = 1, 1.4:
  beginbigop(scale); "big plus";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    draw (centre + op_height/2 * dir  0) -- (centre + op_height/2 * dir 180);
    draw (centre + op_height/2 * dir 90) -- (centre + op_height/2 * dir 270);
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big times";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    z1 - z0 = z3 - z2 = op_width * dir 0;
    z2 - z0 = op_width * dir 90;

    1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

    draw z0 -- z3;
    draw z1 -- z2;
  endchar;
endfor;
charlist current_char - 1: current_char;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "big wedge";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      z3 - z0 = z2 - z1 = op_width * dir 0;
      z1 - z0 = sign * op_height * dir 90;

      1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

      draw z0 -- 1/2[z1, z2] -- z3;
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "big wedge dot";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      z3 - z0 = z2 - z1 = op_width * dir 0;
      z1 - z0 = sign * op_height * dir 90;

      1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

      draw z0 -- 1/2[z1, z2] -- z3;
      fill circle(centre - sign * 1/4op_height * dir 90, 4/3dot_size * sqrt scale);
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "double big wedge";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      z3 - z0 = z2 - z1 = op_width * dir 0;
      z1 - z0 = sign * op_height * dir 90;

      1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

      1/2[z0a,z0b] = z0;
      1/2[z1a,z1b] = 1/2[z1, z2];
      1/2[z2a,z2b] = z3;
      z0b - z0a = z1b - z1a = z2b - z2a = 1/3(plus_size + 11/5rule_thickness) * dir 0;

      draw z0a -- z1a -- z2a;
      draw z0b -- z1b -- z2b;
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "big curly wedge";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      draw prec(centre + sign * op_height/2 * dir 90,
                centre - sign * op_height/2 * dir 90,
                op_width);
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "big curly wedge dot";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      draw prec(centre + sign * op_height/2 * dir 90,
                centre - sign * op_height/2 * dir 90,
                op_width);
      fill circle(centre - sign * 3/8op_height * dir 90, 4/3dot_size * sqrt scale);
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "double big curly wedge";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      1/2[z0,z1] = centre;
      z1 - z0 = 1/3(plus_size + 11/5rule_thickness) * dir 0;

      draw prec(z0 + sign * op_height/2 * dir 90,
                z0 - sign * op_height/2 * dir 90,
                op_width);
      draw prec(z1 + sign * op_height/2 * dir 90,
                z1 - sign * op_height/2 * dir 90,
                op_width);
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "big union";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      draw subset(centre + sign * op_height/2 * dir 90,
                  centre - sign * op_height/2 * dir 90,
                  op_width);
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "big union dot";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      draw subset(centre + sign * op_height/2 * dir 90,
                  centre - sign * op_height/2 * dir 90,
                  op_width);
      fill circle(centre - sign * 1/8op_height * dir 90, 4/3dot_size * sqrt scale);
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "big union plus";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      draw subset(centre + sign * op_height/2 * dir 90,
                  centre - sign * op_height/2 * dir 90,
                  op_width);

      t := 2rule_thickness;
      r := 3/8op_width - t;

      draw (centre - sign * 1/8op_width * dir 90 + r * dir  0)
        -- (centre - sign * 1/8op_width * dir 90 + r * dir 180);
      draw (centre + (r - sign * 1/8op_width) * dir 90)
        -- (centre + (r + sign * 1/8op_width) * dir 270);
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "big square union";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      z3 - z0 = z2 - z1 = op_width * dir 0;
      z1 - z0 = sign * op_height * dir 90;

      1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

      draw z0 -- z1 -- z2 -- z3;
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "big square union dot";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      z3 - z0 = z2 - z1 = op_width * dir 0;
      z1 - z0 = sign * op_height * dir 90;

      1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

      draw z0 -- z1 -- z2 -- z3;
      fill circle(centre - sign * 1/8op_height * dir 90, 4/3dot_size * sqrt scale);
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "big square union plus";

      pickup rule_pen;
      pickup currentpen scaled (4/3 * sqrt scale);

      z3 - z0 = z2 - z1 = op_width * dir 0;
      z1 - z0 = sign * op_height * dir 90;

      1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

      draw z0 -- z1 -- z2 -- z3;

      t := 2rule_thickness;
      r := 3/8op_width - t;

      draw (centre - sign * 1/8op_width * dir 90 + r * dir  0)
        -- (centre - sign * 1/8op_width * dir 90 + r * dir 180);
      draw (centre + (r - sign * 1/8op_width) * dir 90)
        -- (centre + (r + sign * 1/8op_width) * dir 270);
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for scale = 1, 1.4:
  beginbigop(scale); "big circle";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    draw circle(centre, op_height/2);
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big circle minus";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    r := op_height/2 - 11/10rule_thickness;

    draw circle(centre, op_height/2);
    draw (centre + r * left) -- (centre + r * right);
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big circle bar";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    r := op_height/2 - 11/10rule_thickness;

    draw circle(centre, op_height/2);
    draw (centre + r * up) -- (centre + r * down);
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big circle slash";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    r := op_height/2 - 11/10rule_thickness;

    draw circle(centre, op_height/2);
    draw (centre + r * dir  45) -- (centre + r * dir 225);
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big circle backslash";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    r := op_height/2 - 11/10rule_thickness;

    draw circle(centre, op_height/2);
    draw (centre + r * dir 135) -- (centre + r * dir 315);
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big circle plus";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    r := op_height/2 - 11/10rule_thickness;

    draw circle(centre, op_height/2);
    draw (centre + r * left) -- (centre + r * right);
    draw (centre + r * up)   -- (centre + r * down);
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big circle times";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    r := op_height/2 - 11/10rule_thickness;

    draw circle(centre, op_height/2);
    draw (centre + r * dir  45) -- (centre + r * dir 225);
    draw (centre + r * dir 135) -- (centre + r * dir 315);
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big circle dot";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    draw circle(centre, op_height/2);
    fill circle(centre, scale * 1.3dot_size);
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big circle circle";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    draw circle(centre, op_height/2);
    draw circle(centre, op_height/5);
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big circle triangle";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    draw circle(centre, op_height/2);

    pickup rule_pen;

    draw triangle(centre, op_height/5, 90);
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big circle asterisk";
    thick := 4/3rule_thickness * sqrt scale;

    pickup pencircle scaled thick;

    r := op_height/2 - 11/10rule_thickness * (4/3 * sqrt scale);

    draw circle(centre, op_height/2);

    penpos a0(4/3thick,   0 - 7);
    penpos a1(4/3thick,  72 - 7);
    penpos a2(4/3thick, 144 - 7);
    penpos a3(4/3thick, 216 - 7);
    penpos a4(4/3thick, 288 - 7);

    penpos b0(2/3thick,   0 - 7);
    penpos b1(2/3thick,  72 - 7);
    penpos b2(2/3thick, 144 - 7);
    penpos b3(2/3thick, 216 - 7);
    penpos b4(2/3thick, 288 - 7);

    reg_poly_points(a)(5, centre, r, 77);

    z.b0 = z.b1 = z.b2 = z.b3 = z.b4 = centre;

    fill stroke z.a0e -- z.b0e;
    fill stroke z.a1e -- z.b1e;
    fill stroke z.a2e -- z.b2e;
    fill stroke z.a3e -- z.b3e;
    fill stroke z.a4e -- z.b4e;
  endchar;
endfor;
charlist current_char - 1: current_char;

for scale = 1, 1.4:
  beginbigop(scale); "big circle star";
    pickup rule_pen;
    pickup currentpen scaled (4/3 * sqrt scale);

    r := op_height/2 - 11/10rule_thickness * (4/3 * sqrt scale);

    draw circle(centre, op_height/2);

    pickup rule_pen;

    reg_poly_points(a)(5, centre, r, 90);
    reg_poly_points(b)(5, centre, r/10, 126);

    draw z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
    fill z.a0 -- z.b0 -- z.a1 -- z.b1 -- z.a2 -- z.b2 -- z.a3 -- z.b3 -- z.a4 -- z.b4 -- cycle;
  endchar;
endfor;
charlist current_char - 1: current_char;

for sign = 1, -1:
  for scale = 1, 1.4:
    beginbigop(scale); "product";
      draw_product(centre, op_width, op_height, sign, 5/3rule_thickness * sqrt scale);
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for scale = 1, 1.4:
  beginbigop(scale); "sum";
    thick := 4/3rule_thickness * sqrt scale;
    thin  := 2/3thick;

    z1 - z0 = z3 - z2 = op_width * dir 0;
    z2 - z0 = op_height * dir 90;

    1/2[1/2[z0,z1], 1/2[z2,z3]] = centre;

    z4 - z1 = z3 - z5 = 1/5op_height * dir 90;

    z6 = whatever[z0,z1] = z4 - whatever * dir 77;
    z7 = whatever[z2,z3] = z5 + whatever * dir -77;

    penpos 0(thick,  90);
    penpos 6(thick,  90);
    penpos 4(thin,  167);
    penpos 2(thin,  -90);
    penpos 7(thin,  -90);
    penpos 5(thin,  203);

    z8 = centre;
    penpos 8(2thin, 20);

    z9 = z8r + whatever * (z2r - z8l) = whatever[z2r,z7r];

    z10 = z0l + thin * dir 90;
    z11 = z8r + whatever * (z10 - z8l);
    y11 = y10;

    z12 = whatever[z10,z8l];
    y12 = y0r;

    fill z0l -- z6l -- z4l -- z4r{-dir 77} .. {dir 180}1/4[z6r,z0r] -- z12 -- z10 -- cycle;
    fill z2l -- z7l -- z5l -- z5r{dir 113} .. {dir 180}1/4[z7r,z2r] -- z2r -- cycle;
    fill z2r -- z8l -- z8r -- z9 -- cycle;
    fill z10 -- z8l -- z8r -- z11 -- cycle;
  endchar;
endfor;
charlist current_char - 1: current_char;

def draw_integral(suffix $)(expr scale, center) =
  thick := 2rule_thickness * sqrt (sqrt scale);
  thin  := 1/2thick;

  penpos0$(4/5thick, 0);
  penpos1$(4/5thick, 0);
  penpos2$(5/11thick, -90);
  penpos3$(4/5thick, 0);
  penpos4$(5/11thick, -90);

  z0$ = 1/2[z1$,z3$] = 1/2[z2$,z4$];
  z1$ - z3$ = whatever * dir 80;
  z2$ - z4$ = whatever * dir 70;

  x0$l = xpart centre;
  top y2$ = h;
  bot y4$ = -d;
  y1$ = 1/2[y0$,y2$];

  penpos5$(2/3thick,-135);
  penpos6$(2/3thick,-135);
  y5$ = 1/9[y2$, y1$];
  x5$ = 8/5[x1$r, x2$r];
  y6$ = 1/9[y4$, y3$];
  x6$ = 8/5[x3$l, x4$l];

  fill z5$r -- z5$l .. z2$l{left} .. {z3$-z1$}z1$l -- z3$l{z3$-z1$} .. tension 1.5 .. {left}z4$l .. z6$l -- z6$r
    .. z4$r{right} .. {z1$-z3$}z3$r -- z1$r{z1$-z3$} .. tension 1.5 .. {right}z2$r .. cycle;
  fill circle(z5$, 1/3thick);
  fill circle(z6$, 1/3thick);

  penlabels(0$,1$,2$,3$,4$,5$,6$);
enddef;

for number = 0, 1, 2, 3:
  for scale = 1, 1.8:

    display_shift# := (1 + 5/2(scale-1)) * 1/4order_width#;
    text_shift#    := (scale-1) * 1/2order_width#;
    define_whole_pixels(display_shift, text_shift);

    beginsymbol(scale * (1/2 + 2/3number) * order_width# + 2side_bearing# + display_shift# - text_shift#,
                ((scale - 1)/2 + 1) * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#,
                (scale - 1)/2 * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#);
      "integral";

      italcorr (1 + 3/2(scale-1)) * 2/3order_width#; % kerning between upper limit and lower limit

      pair centre;

      for i = 0 upto number:
        centre := ((w - scale * (number - 2*i) * 2/3order_width + display_shift + text_shift)/2,
                   (h - d)/2);

        draw_integral([i])(scale, centre);
      endfor;
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for scale = 1, 1.8:

  display_shift# := (1 + 5/2(scale-1)) * 1/4order_width#;
  text_shift#    := (scale-1) * 1/2order_width#;
  define_whole_pixels(display_shift, text_shift);

  beginsymbol(scale * (1/2 + 1) * order_width# + 2side_bearing# + display_shift# - text_shift#,
              ((scale - 1)/2 + 1) * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#,
              (scale - 1)/2 * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#);
    "integral dots";

    italcorr (1 + 3/2(scale-1)) * 2/3order_width#; % kerning between upper limit and lower limit

    pair centre;

    centre := ((w - 2scale * order_width + display_shift + text_shift)/2,
               (h - d)/2);

    draw_integral([0])(scale, centre);

    centre := ((w + 2scale * order_width + display_shift + text_shift)/2,
               (h - d)/2);

    draw_integral([2])(scale, centre);

    z0 = 1/4[z0[0],z0[2]];
    z1 = 2/4[z0[0],z0[2]];
    z2 = 3/4[z0[0],z0[2]];

    fill circle(z0, dot_size);
    fill circle(z1, dot_size);
    fill circle(z2, dot_size);
  endchar;
endfor;
charlist current_char - 1: current_char;

for sign = 1, -1:
  for scale = 1, 1.8:

    display_shift# := (1 + 5/2(scale-1)) * 1/4order_width#;
    text_shift#    := (scale-1) * 1/2order_width#;
    define_whole_pixels(display_shift, text_shift);

    beginsymbol(scale * 1/2order_width# + 2side_bearing# + display_shift# - text_shift#,
                ((scale - 1)/2 + 1) * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#,
                (scale - 1)/2 * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#);
      "landup/down integral";

      italcorr (1 + 3/2(scale-1)) * 2/3order_width#; % kerning between upper limit and lower limit

      pair centre;

      centre := ((w + display_shift + text_shift)/2, (h - d)/2);

      draw_integral(a)(scale, centre);

      pickup pencircle scaled 1/2thick;

      z0 = z0a + sign * sqrt scale * (-2thick, -2/3thick);
      z1 = z0a + sign * sqrt scale * ( 0,       2/3thick);
      z2 = z0a + sign * sqrt scale * ( 2thick, -2/3thick);

      draw z0 .. z1 .. z2;
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for scale = 1, 1.8:

  display_shift# := (1 + 5/2(scale-1)) * 1/4order_width#;
  text_shift#    := (scale-1) * 1/2order_width#;
  define_whole_pixels(display_shift, text_shift);

  beginsymbol(scale * 1/2order_width# + 2side_bearing# + display_shift# - text_shift#,
              ((scale - 1)/2 + 1) * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#,
              (scale - 1)/2 * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#);
    "stroked integral";

    italcorr (1 + 3/2(scale-1)) * 2/3order_width#; % kerning between upper limit and lower limit

    pair centre;

    centre := ((w + display_shift + text_shift)/2, (h - d)/2);

    draw_integral(a)(scale, centre);

    alpha := angle (z1a - z3a) - 70;

    pickup pencircle scaled 1/2thick;

    draw (z0a - sqrt scale * 2thick * dir alpha) -- (z0a + sqrt scale * 2thick * dir alpha);
  endchar;
endfor;
charlist current_char - 1: current_char;

for number = 0, 1:
  for scale = 1, 1.8:

    display_shift# := (1 + 5/2(scale-1)) * 1/4order_width#;
    text_shift#    := (scale-1.3) * 4/5order_width#;
    define_whole_pixels(display_shift, text_shift);

    beginsymbol(scale * (1/2 + 2/3number) * order_width# + 2side_bearing# + display_shift# - text_shift#,
                ((scale - 1)/2 + 1) * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#,
                (scale - 1)/2 * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#);
      "contour integral";

      italcorr (1 + 3/2(scale-1)) * 2/3order_width#; % kerning between upper limit and lower limit

      pair centre;

      for i = 0 upto number:
        centre := ((w - scale * (number - 2*i) * 2/3order_width + display_shift + text_shift)/2,
                   (h - d)/2);

        draw_integral([i])(scale, centre);
      endfor;

      centre := 1/2[z0[0], z0[number]];

      pickup pencircle scaled 5/12thick;

      if number = 0:
        draw circle(centre, 2thick * sqrt scale);
      else:
        draw super_ellipse(centre,
                           (2thick + number * 5/5thick) * sqrt scale,
                           (2thick + number * 1/5thick) * sqrt scale,
                           7/8, 0);
      fi;
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for alpha = -90, 90:
  for sign = 1, -1:
    for scale = 1, 1.8:

      display_shift# := (1 + 5/2(scale-1)) * 1/4order_width#;
      text_shift#    := (scale-1.3) * 4/5order_width#;
      define_whole_pixels(display_shift, text_shift);

      beginsymbol(scale * 1/2order_width# + 2side_bearing# + display_shift# - text_shift#,
                  ((scale - 1)/2 + 1) * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#,
                  (scale - 1)/2 * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#);
        "oriented contour integral";

        italcorr (1 + 3/2(scale-1)) * 2/3order_width#; % kerning between upper limit and lower limit

        pair centre;
        centre := ((w+display_shift+text_shift)/2, (h-d)/2);

        draw_integral(a)(scale, centre);

        pickup pencircle scaled 5/12thick;

        r := 2thick * sqrt scale;

        beta := alpha + angle (z1a - z3a) + 25sign;

        reg_poly_points(a)(8, z0a, r, beta);

        z0 = z0a + r * dir (beta + 10);
        z1 = z0a + r * dir (beta - 10);

        draw z0{dir (beta + 100)} .. z.a1 .. z.a2 .. z.a3 .. z.a4 .. z.a5 .. z.a6 .. z.a7 ..
            {dir (beta + 80)}z1;

        if sign > 0:
          draw arrowhead(z1, (beta + 65), 1/2scale * arrow_spread);
        else:
          draw arrowhead(z0, (beta - 65), 1/2scale * arrow_spread);
        fi;
      endchar;
    endfor;
    charlist current_char - 1: current_char;
  endfor;
endfor;

for sign = 1, -1:
  for scale = 1, 1.8:

    display_shift# := 0 * (1 + 5/2(scale-1)) * 1/4order_width#;
    text_shift#    := 0 * (scale-1) * 1/2order_width#;
    define_whole_pixels(display_shift, text_shift);

    beginsymbol(scale * 1/2order_width# + 2side_bearing# + display_shift# - text_shift#,
                ((scale - 1)/2 + 1) * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#,
                (scale - 1)/2 * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#);
      "partial landup/down integral";

%      italcorr (1 + 3/2(scale-1)) * 2/3order_width#; % kerning between upper limit and lower limit

      pair centre;

      centre := (17/32w, (h-d)/2);

      pickup pencircle scaled 1/2thick;

      z0 = centre + sign * sqrt scale * (-2thick, -2/3thick);
      z1 = centre + sign * sqrt scale * ( 0,       2/3thick);
      z2 = centre + sign * sqrt scale * ( 2thick, -2/3thick);

      draw z0 .. z1 .. z2;
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for scale = 1, 1.8:

  display_shift# := 0 * (1 + 5/2(scale-1)) * 1/4order_width#;
  text_shift#    := 0 * (scale-1) * 1/2order_width#;
  define_whole_pixels(display_shift, text_shift);

  beginsymbol(scale * 1/2order_width# + 2side_bearing# + display_shift# - text_shift#,
              ((scale - 1)/2 + 1) * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#,
              (scale - 1)/2 * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#);
    "partial stroked integral";

%    italcorr (1 + 3/2(scale-1)) * 2/3order_width#; % kerning between upper limit and lower limit

    pair centre;

    centre := (17/32w, (h-d)/2);

    alpha := 10;

    pickup pencircle scaled 1/2thick;

    draw (centre - sqrt scale * 2thick * dir alpha) -- (centre + sqrt scale * 2thick * dir alpha);
  endchar;
endfor;
charlist current_char - 1: current_char;

for number = 0, 1:
  for scale = 1, 1.8:

    display_shift# := 0 * (1 + 5/2(scale-1)) * 1/4order_width#;
    text_shift#    := 0 * (scale-1.3) * 4/5order_width#;
    define_whole_pixels(display_shift, text_shift);

    beginsymbol(scale * (1/2 + 2/3number) * order_width# + 2side_bearing# + display_shift# - text_shift#,
                ((scale - 1)/2 + 1) * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#,
                (scale - 1)/2 * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#);
      "partial contour integral";

%      italcorr (1 + 3/2(scale-1)) * 2/3order_width#; % kerning between upper limit and lower limit

      pair centre;

      centre := (17/32w, (h-d)/2);

      pickup pencircle scaled 5/12thick;

      if number = 0:
        draw circle(centre, 2thick * sqrt scale);
      else:
        draw super_ellipse(centre,
                           (2thick + number * 5/5thick) * sqrt scale,
                           (2thick + number * 1/5thick) * sqrt scale,
                           7/8, 0);
      fi;
    endchar;
  endfor;
  charlist current_char - 1: current_char;
endfor;

for alpha = -90, 90:
  for sign = 1, -1:
    for scale = 1, 1.8:

      display_shift# := 0 * (1 + 5/2(scale-1)) * 1/4order_width#;
      text_shift#    := 0 * (scale-1.3) * 4/5order_width#;
      define_whole_pixels(display_shift, text_shift);

      beginsymbol(scale * 1/2order_width# + 2side_bearing# + display_shift# - text_shift#,
                  ((scale - 1)/2 + 1) * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#,
                  (scale - 1)/2 * 1.4asc_height# + scale * 1/6equal_spread# + 2/3rule_thickness#);
        "partial oriented contour integral";

%        italcorr (1 + 3/2(scale-1)) * 2/3order_width#; % kerning between upper limit and lower limit

        pair centre;
        centre := (17/32w, (h-d)/2);

        pickup pencircle scaled 5/12thick;

        r := 2thick * sqrt scale;

        beta := alpha + 80 + 25sign;

        reg_poly_points(a)(8, centre, r, beta);

        z0 = centre + r * dir (beta + 10);
        z1 = centre + r * dir (beta - 10);

        draw z0{dir (beta + 100)} .. z.a1 .. z.a2 .. z.a3 .. z.a4 .. z.a5 .. z.a6 .. z.a7 ..
            {dir (beta + 80)}z1;

        if sign > 0:
          draw arrowhead(z1, (beta + 65), 1/2scale * arrow_spread);
        else:
          draw arrowhead(z0, (beta - 65), 1/2scale * arrow_spread);
        fi;
      endchar;
    endfor;
    charlist current_char - 1: current_char;
  endfor;
endfor;

